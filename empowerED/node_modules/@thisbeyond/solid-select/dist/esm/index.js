import { mergeProps, createSignal, createEffect, on, createMemo, createResource, getOwner, onCleanup, createContext, useContext, splitProps, Show, For } from 'solid-js';
import { memo, insert, template, createComponent, addEventListener, effect, className, setAttribute, delegateEvents } from 'solid-js/web';

const createSelect = props => {
  const config = mergeProps({
    multiple: false,
    disabled: false,
    optionToValue: option => option,
    isOptionDisabled: option => false
  }, props);

  const parseValue = value => {
    if (config.multiple && Array.isArray(value)) {
      return value;
    } else if (!config.multiple && !Array.isArray(value)) {
      return value !== null ? [value] : [];
    } else {
      throw new Error(`Incompatible value type for ${config.multiple ? "multple" : "single"} select.`);
    }
  };

  const [_value, _setValue] = createSignal(config.initialValue !== undefined ? parseValue(config.initialValue) : []);

  const value = () => config.multiple ? _value() : _value()[0] || null;

  const setValue = value => _setValue(parseValue(value));

  const clearValue = () => _setValue([]);

  const hasValue = () => !!(config.multiple ? value().length : value());

  createEffect(on(_value, () => config.onChange?.(value()), {
    defer: true
  }));
  const [inputValue, setInputValue] = createSignal("");

  const clearInputValue = () => setInputValue("");

  const hasInputValue = () => !!inputValue().length;

  createEffect(on(inputValue, inputValue => config.onInput?.(inputValue), {
    defer: true
  }));
  createEffect(on(inputValue, inputValue => {
    if (inputValue && !isOpen()) {
      setIsOpen(true);
    }
  }, {
    defer: true
  }));
  const options = typeof config.options === "function" ? createMemo(() => config.options(inputValue()), config.options(inputValue())) : () => config.options;

  const optionsCount = () => options().length;

  const pickOption = option => {
    if (config.isOptionDisabled(option)) return;
    const value = config.optionToValue(option);

    if (config.multiple) {
      setValue([..._value(), value]);
    } else {
      setValue(value);
      setIsActive(false);
    }

    setIsOpen(false);
  };

  const [isActive, setIsActive] = createSignal(false);
  const [isOpen, setIsOpen] = createSignal(false);

  const toggleOpen = () => setIsOpen(!isOpen());

  const [focusedOptionIndex, setFocusedOptionIndex] = createSignal(-1);

  const focusedOption = () => options()[focusedOptionIndex()];

  const isOptionFocused = option => option === focusedOption();

  const focusOption = direction => {
    if (!optionsCount()) setFocusedOptionIndex(-1);
    const max = optionsCount() - 1;
    const delta = direction === "next" ? 1 : -1;
    let index = focusedOptionIndex() + delta;

    if (index > max) {
      index = 0;
    }

    if (index < 0) {
      index = max;
    }

    setFocusedOptionIndex(index);
  };

  const focusPreviousOption = () => focusOption("previous");

  const focusNextOption = () => focusOption("next");

  createEffect(on(options, options => {
    if (isOpen()) setFocusedOptionIndex(Math.min(0, options.length - 1));
  }, {
    defer: true
  }));
  createEffect(on(() => config.disabled, isDisabled => {
    if (isDisabled && isOpen()) {
      setIsOpen(false);
    }
  }));
  createEffect(on(isOpen, isOpen => {
    if (isOpen) {
      if (focusedOptionIndex() === -1) focusNextOption();
      setIsActive(true);
    } else {
      if (focusedOptionIndex() > -1) setFocusedOptionIndex(-1);
      setInputValue("");
    }
  }, {
    defer: true
  }));
  createEffect(on(focusedOptionIndex, focusedOptionIndex => {
    if (focusedOptionIndex > -1 && !isOpen()) {
      setIsOpen(true);
    }
  }, {
    defer: true
  }));

  const onFocusIn = () => setIsActive(true);

  const onFocusOut = () => {
    setIsActive(false);
    setIsOpen(false);
  };

  const onMouseDown = event => event.preventDefault();

  const onClick = event => {
    if (!config.disabled && !hasInputValue()) toggleOpen();
  };

  const onInput = event => {
    setInputValue(event.target.value);
  };

  const onKeyDown = event => {
    switch (event.key) {
      case "ArrowDown":
        focusNextOption();
        break;

      case "ArrowUp":
        focusPreviousOption();
        break;

      case "Enter":
        if (isOpen() && focusedOption()) {
          pickOption(focusedOption());
          break;
        }

        return;

      case "Escape":
        if (isOpen()) {
          setIsOpen(false);
          break;
        }

        return;

      case "Delete":
      case "Backspace":
        if (inputValue()) {
          return;
        }

        if (config.multiple) {
          const currentValue = value();
          setValue([...currentValue.slice(0, -1)]);
        } else {
          clearValue();
        }

        break;

      case " ":
        if (inputValue()) {
          return;
        }

        if (!isOpen()) {
          setIsOpen(true);
        } else {
          if (focusedOption()) {
            pickOption(focusedOption());
          }
        }

        break;

      case "Tab":
        if (focusedOption() && isOpen()) {
          pickOption(focusedOption());
          break;
        }

        return;

      default:
        return;
    }

    event.preventDefault();
    event.stopPropagation();
  };

  return {
    options,
    value,
    setValue,
    hasValue,
    clearValue,
    inputValue,
    setInputValue,
    hasInputValue,
    clearInputValue,
    isOpen,
    setIsOpen,
    toggleOpen,
    isActive,
    setIsActive,

    get multiple() {
      return config.multiple;
    },

    get disabled() {
      return config.disabled;
    },

    pickOption,
    isOptionFocused,
    isOptionDisabled: config.isOptionDisabled,
    onFocusIn,
    onFocusOut,
    onMouseDown,
    onClick,
    onInput,
    onKeyDown
  };
};

const _tmpl$$2 = /*#__PURE__*/template(`<mark></mark>`, 2);

const SCORING = {
  NO_MATCH: 0,
  MATCH: 1,
  WORD_START: 2,
  START: 3
};

const fuzzySearch = (value, target) => {
  let score = SCORING.NO_MATCH;
  let matches = [];

  if (value.length <= target.length) {
    const valueChars = Array.from(value.toLocaleLowerCase());
    const targetChars = Array.from(target.toLocaleLowerCase());
    let delta = SCORING.START;

    outer: for (let valueIndex = 0, targetIndex = 0; valueIndex < valueChars.length; valueIndex++) {
      while (targetIndex < targetChars.length) {
        if (targetChars[targetIndex] === valueChars[valueIndex]) {
          matches[targetIndex] = true;

          if (delta === SCORING.MATCH && targetChars[targetIndex - 1] === " " && targetChars[targetIndex] !== " ") {
            delta = SCORING.WORD_START;
          }

          score += delta;
          delta++;
          targetIndex++;
          continue outer;
        } else {
          delta = SCORING.MATCH;
          targetIndex++;
        }
      } // Didn't exhaust search value.


      score = SCORING.NO_MATCH;
      matches.length = 0;
    }
  }

  return {
    target,
    score,
    matches
  };
};

const fuzzyHighlight = (searchResult, highlighter = match => (() => {
  const _el$ = _tmpl$$2.cloneNode(true);

  insert(_el$, match);

  return _el$;
})()) => {
  const target = searchResult.target;
  const matches = searchResult.matches;
  const separator = "\x00";
  const highlighted = [];
  let open = false;

  for (let index = 0; index < target.length; index++) {
    const char = target[index];
    const matched = matches[index];

    if (!open && matched) {
      highlighted.push(separator);
      open = true;
    } else if (open && !matched) {
      highlighted.push(separator);
      open = false;
    }

    highlighted.push(char);
  }

  if (open) {
    highlighted.push(separator);
    open = false;
  }

  return memo(() => highlighted.join("").split(separator).map((part, index) => index % 2 ? highlighter(part) : part));
};

const fuzzySort = (value, items, key) => {
  const sorted = [];

  for (let index = 0; index < items.length; index++) {
    const item = items[index];
    const target = key ? item[key] : item;
    const result = fuzzySearch(value, target);

    if (result.score) {
      sorted.push({ ...result,
        item,
        index
      });
    }
  }

  sorted.sort((a, b) => {
    let delta = b.score - a.score;

    if (delta === 0) {
      delta = a.index - b.index;
    }

    return delta;
  });
  return sorted;
};

const _tmpl$$1 = /*#__PURE__*/template(`<mark></mark>`, 2);

const createOptions = (values, userConfig) => {
  const config = Object.assign({
    filterable: true,
    disable: () => false
  }, userConfig || {});

  const getLabel = value => config?.key !== undefined ? value[config.key] : value;

  const options = inputValue => {
    const initialValues = typeof values === "function" ? values(inputValue) : values;
    let createdOptions = initialValues.map(value => {
      return {
        label: getLabel(value),
        value: value,
        disabled: config.disable(value)
      };
    });

    if (config.filterable && inputValue) {
      createdOptions = fuzzySort(inputValue, createdOptions, "label").map(result => ({ ...result.item,
        label: fuzzyHighlight(result)
      }));
    }

    if (config.createable !== undefined) {
      const trimmedValue = inputValue.trim();
      const exists = createdOptions.some(option => areEqualIgnoringCase(inputValue, getLabel(option.value)));

      if (trimmedValue && !exists) {
        let value;

        if (typeof config.createable === "function") {
          value = config.createable(trimmedValue);
        } else {
          value = config.key ? {
            [config.key]: trimmedValue
          } : trimmedValue;
        }

        const option = {
          label: ["Create ", (() => {
            const _el$ = _tmpl$$1.cloneNode(true);

            insert(_el$, () => getLabel(value));

            return _el$;
          })()],
          value,
          disabled: false
        };
        createdOptions = [...createdOptions, option];
      }
    }

    return createdOptions;
  };

  const optionToValue = option => option.value;

  const format = (item, type) => type === "option" ? item.label : getLabel(item);

  const isOptionDisabled = option => option.disabled;

  return {
    options,
    optionToValue,
    isOptionDisabled,
    format
  };
};

const areEqualIgnoringCase = (firstString, secondString) => firstString.localeCompare(secondString, undefined, {
  sensitivity: "base"
}) === 0;

const createAsyncOptions = (fetcher, timeout = 250) => {
  const [inputValue, setInputValue] = createSignal("");
  const throttledFetcher = throttle(fetcher, timeout);
  const [asyncOptions] = createResource(inputValue, throttledFetcher, {
    initialValue: []
  });
  return {
    get options() {
      return asyncOptions();
    },

    get loading() {
      return asyncOptions.loading;
    },

    onInput: setInputValue,
    readonly: false
  };
};

const throttle = (callback, threshold) => {
  let activePromise = null,
      timeoutId,
      lastArgs;

  const wait = () => new Promise(resolve => timeoutId = setTimeout(resolve, threshold));

  const throttled = (...args) => {
    lastArgs = args;
    if (activePromise) return activePromise;
    activePromise = wait().then(() => {
      activePromise = null;
      return callback(...lastArgs);
    });
    return activePromise;
  };

  const clear = () => {
    clearTimeout(timeoutId);
    activePromise = null;
  };

  if (getOwner()) onCleanup(clear);
  return Object.assign(throttled, {
    clear
  });
};

const _tmpl$ = /*#__PURE__*/template(`<div></div>`, 2),
      _tmpl$2 = /*#__PURE__*/template(`<div class="solid-select-control"></div>`, 2),
      _tmpl$3 = /*#__PURE__*/template(`<div class="solid-select-placeholder"></div>`, 2),
      _tmpl$4 = /*#__PURE__*/template(`<div class="solid-select-single-value"></div>`, 2),
      _tmpl$5 = /*#__PURE__*/template(`<div class="solid-select-multi-value"><button type="button" class="solid-select-multi-value-remove">⨯</button></div>`, 4),
      _tmpl$6 = /*#__PURE__*/template(`<input class="solid-select-input" type="text" tabindex="0" autocomplete="off" autocapitalize="none" size="1">`, 1),
      _tmpl$7 = /*#__PURE__*/template(`<div class="solid-select-list"></div>`, 2),
      _tmpl$8 = /*#__PURE__*/template(`<div class="solid-select-list-placeholder"></div>`, 2),
      _tmpl$9 = /*#__PURE__*/template(`<div class="solid-select-option"></div>`, 2);
const SelectContext = createContext();

const useSelect = () => {
  const context = useContext(SelectContext);
  if (!context) throw new Error("No SelectContext found in ancestry.");
  return context;
};

const Select = props => {
  const [selectProps, local] = splitProps(mergeProps({
    format: (data, type) => data,
    placeholder: "Select...",
    readonly: typeof props.options !== "function",
    loading: false,
    loadingPlaceholder: "Loading...",
    emptyPlaceholder: "No options"
  }, props), ["options", "optionToValue", "isOptionDisabled", "multiple", "disabled", "onInput", "onChange"]);
  const select = createSelect(selectProps);
  createEffect(on(() => local.initialValue, value => value !== undefined && select.setValue(value)));
  return createComponent(SelectContext.Provider, {
    value: select,

    get children() {
      return createComponent(Container, {
        get ["class"]() {
          return local.class;
        },

        get children() {
          return [createComponent(Control, {
            get id() {
              return local.id;
            },

            get name() {
              return local.name;
            },

            get format() {
              return local.format;
            },

            get placeholder() {
              return local.placeholder;
            },

            get autofocus() {
              return local.autofocus;
            },

            get readonly() {
              return local.readonly;
            }

          }), createComponent(List, {
            get loading() {
              return local.loading;
            },

            get loadingPlaceholder() {
              return local.loadingPlaceholder;
            },

            get emptyPlaceholder() {
              return local.emptyPlaceholder;
            },

            get format() {
              return local.format;
            }

          })];
        }

      });
    }

  });
};

const Container = props => {
  const select = useSelect();
  return (() => {
    const _el$ = _tmpl$.cloneNode(true);

    _el$.$$mousedown = event => {
      select.onMouseDown(event);
      event.currentTarget.getElementsByTagName("input")[0].focus();
    };

    addEventListener(_el$, "focusout", select.onFocusOut, true);

    addEventListener(_el$, "focusin", select.onFocusIn, true);

    insert(_el$, () => props.children);

    effect(_p$ => {
      const _v$ = `solid-select-container ${props.class !== undefined ? props.class : ""}`,
            _v$2 = select.disabled;
      _v$ !== _p$._v$ && className(_el$, _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && setAttribute(_el$, "data-disabled", _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });

    return _el$;
  })();
};

const Control = props => {
  const select = useSelect();

  const removeValue = index => {
    const value = select.value();
    select.setValue([...value.slice(0, index), ...value.slice(index + 1)]);
  };

  return (() => {
    const _el$2 = _tmpl$2.cloneNode(true);

    addEventListener(_el$2, "click", select.onClick, true);

    insert(_el$2, createComponent(Show, {
      get when() {
        return memo(() => !!!select.hasValue(), true)() && !select.hasInputValue();
      },

      get children() {
        return createComponent(Placeholder, {
          get children() {
            return props.placeholder;
          }

        });
      }

    }), null);

    insert(_el$2, createComponent(Show, {
      get when() {
        return memo(() => !!(select.hasValue() && !select.multiple), true)() && !select.hasInputValue();
      },

      get children() {
        return createComponent(SingleValue, {
          get children() {
            return props.format(select.value(), "value");
          }

        });
      }

    }), null);

    insert(_el$2, createComponent(Show, {
      get when() {
        return select.hasValue() && select.multiple;
      },

      get children() {
        return createComponent(For, {
          get each() {
            return select.value();
          },

          children: (value, index) => createComponent(MultiValue, {
            onRemove: () => removeValue(index()),

            get children() {
              return props.format(value, "value");
            }

          })
        });
      }

    }), null);

    insert(_el$2, createComponent(Input, {
      get id() {
        return props.id;
      },

      get name() {
        return props.name;
      },

      get autofocus() {
        return props.autofocus;
      },

      get readonly() {
        return props.readonly;
      }

    }), null);

    effect(_p$ => {
      const _v$3 = select.multiple,
            _v$4 = select.hasValue(),
            _v$5 = select.disabled;

      _v$3 !== _p$._v$3 && setAttribute(_el$2, "data-multiple", _p$._v$3 = _v$3);
      _v$4 !== _p$._v$4 && setAttribute(_el$2, "data-has-value", _p$._v$4 = _v$4);
      _v$5 !== _p$._v$5 && setAttribute(_el$2, "data-disabled", _p$._v$5 = _v$5);
      return _p$;
    }, {
      _v$3: undefined,
      _v$4: undefined,
      _v$5: undefined
    });

    return _el$2;
  })();
};

const Placeholder = props => {
  return (() => {
    const _el$3 = _tmpl$3.cloneNode(true);

    insert(_el$3, () => props.children);

    return _el$3;
  })();
};

const SingleValue = props => {
  return (() => {
    const _el$4 = _tmpl$4.cloneNode(true);

    insert(_el$4, () => props.children);

    return _el$4;
  })();
};

const MultiValue = props => {
  useSelect();
  return (() => {
    const _el$5 = _tmpl$5.cloneNode(true),
          _el$6 = _el$5.firstChild;

    insert(_el$5, () => props.children, _el$6);

    _el$6.$$click = event => {
      event.stopPropagation();
      props.onRemove();
    };

    return _el$5;
  })();
};

const Input = props => {
  const select = useSelect();
  return (() => {
    const _el$7 = _tmpl$6.cloneNode(true);

    _el$7.$$mousedown = event => {
      event.stopPropagation();
    };

    _el$7.$$keydown = event => {
      select.onKeyDown(event);

      if (!event.defaultPrevented) {
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
          event.target.blur();
        }
      }
    };

    addEventListener(_el$7, "input", select.onInput, true);

    effect(_p$ => {
      const _v$6 = props.id,
            _v$7 = props.name,
            _v$8 = select.multiple,
            _v$9 = select.isActive(),
            _v$10 = props.autofocus,
            _v$11 = props.readonly,
            _v$12 = select.disabled;

      _v$6 !== _p$._v$6 && setAttribute(_el$7, "id", _p$._v$6 = _v$6);
      _v$7 !== _p$._v$7 && setAttribute(_el$7, "name", _p$._v$7 = _v$7);
      _v$8 !== _p$._v$8 && setAttribute(_el$7, "data-multiple", _p$._v$8 = _v$8);
      _v$9 !== _p$._v$9 && setAttribute(_el$7, "data-is-active", _p$._v$9 = _v$9);
      _v$10 !== _p$._v$10 && (_el$7.autofocus = _p$._v$10 = _v$10);
      _v$11 !== _p$._v$11 && (_el$7.readOnly = _p$._v$11 = _v$11);
      _v$12 !== _p$._v$12 && (_el$7.disabled = _p$._v$12 = _v$12);
      return _p$;
    }, {
      _v$6: undefined,
      _v$7: undefined,
      _v$8: undefined,
      _v$9: undefined,
      _v$10: undefined,
      _v$11: undefined,
      _v$12: undefined
    });

    effect(() => _el$7.value = select.inputValue());

    return _el$7;
  })();
};

const List = props => {
  const select = useSelect();
  return createComponent(Show, {
    get when() {
      return select.isOpen();
    },

    get children() {
      const _el$8 = _tmpl$7.cloneNode(true);

      insert(_el$8, createComponent(Show, {
        get when() {
          return !props.loading;
        },

        get fallback() {
          return (() => {
            const _el$9 = _tmpl$8.cloneNode(true);

            insert(_el$9, () => props.loadingPlaceholder);

            return _el$9;
          })();
        },

        get children() {
          return createComponent(For, {
            get each() {
              return select.options();
            },

            get fallback() {
              return (() => {
                const _el$10 = _tmpl$8.cloneNode(true);

                insert(_el$10, () => props.emptyPlaceholder);

                return _el$10;
              })();
            },

            children: option => createComponent(Option, {
              option: option,

              get children() {
                return props.format(option, "option");
              }

            })
          });
        }

      }));

      return _el$8;
    }

  });
};

const Option = props => {
  const select = useSelect();

  const scrollIntoViewOnFocus = element => {
    createEffect(() => {
      if (select.isOptionFocused(props.option)) {
        element.scrollIntoView({
          block: "nearest"
        });
      }
    });
  };

  return (() => {
    const _el$11 = _tmpl$9.cloneNode(true);

    _el$11.$$click = () => select.pickOption(props.option);

    scrollIntoViewOnFocus(_el$11);

    insert(_el$11, () => props.children);

    effect(_p$ => {
      const _v$13 = select.isOptionDisabled(props.option),
            _v$14 = select.isOptionFocused(props.option);

      _v$13 !== _p$._v$13 && setAttribute(_el$11, "data-disabled", _p$._v$13 = _v$13);
      _v$14 !== _p$._v$14 && setAttribute(_el$11, "data-focused", _p$._v$14 = _v$14);
      return _p$;
    }, {
      _v$13: undefined,
      _v$14: undefined
    });

    return _el$11;
  })();
};

delegateEvents(["focusin", "focusout", "mousedown", "click", "input", "keydown"]);

export { Container, Control, Input, List, MultiValue, Option, Placeholder, Select, SelectContext, SingleValue, createAsyncOptions, createOptions, createSelect, fuzzyHighlight, fuzzySearch, fuzzySort, useSelect };
//# sourceMappingURL=index.js.map
